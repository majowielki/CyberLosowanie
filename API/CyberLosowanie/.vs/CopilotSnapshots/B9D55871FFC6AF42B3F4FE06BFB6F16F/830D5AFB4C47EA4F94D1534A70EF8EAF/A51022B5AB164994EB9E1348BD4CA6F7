using CyberLosowanie.Constants;
using CyberLosowanie.Exceptions;
using CyberLosowanie.Models;
using CyberLosowanie.Models.Dto;
using CyberLosowanie.Repositories;
using Microsoft.EntityFrameworkCore;

namespace CyberLosowanie.Services
{
    public class CyberekService : ICyberekService
    {
        private readonly ICyberekRepository _cyberekRepository;
        private readonly IApplicationUserRepository _userRepository;
        private readonly IGiftingService _giftingService;
        private readonly IValidationService _validationService;

        public CyberekService(
            ICyberekRepository cyberekRepository,
            IApplicationUserRepository userRepository,
            IGiftingService giftingService,
            IValidationService validationService)
        {
            _cyberekRepository = cyberekRepository ?? throw new ArgumentNullException(nameof(cyberekRepository));
            _userRepository = userRepository ?? throw new ArgumentNullException(nameof(userRepository));
            _giftingService = giftingService ?? throw new ArgumentNullException(nameof(giftingService));
            _validationService = validationService ?? throw new ArgumentNullException(nameof(validationService));
        }

        public async Task<IEnumerable<Cyberek>> GetAllCyberkiAsync()
        {
            try
            {
                return await _cyberekRepository.GetAllAsync();
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException("Failed to retrieve cyberki", ex);
            }
        }

        public async Task<Cyberek> GetCyberekByIdAsync(int id)
        {
            var validationErrors = _validationService.ValidateCyberekId(id);
            if (validationErrors.Any())
            {
                throw new BusinessValidationException(validationErrors);
            }

            var cyberek = await _cyberekRepository.GetByIdAsync(id);
            if (cyberek == null)
            {
                throw new CyberekNotFoundException(id);
            }

            return cyberek;
        }

        public async Task<List<int>> GetAvailableGiftTargetsAsync(int cyberekId)
        {
            var validationErrors = _validationService.ValidateCyberekId(cyberekId);
            if (validationErrors.Any())
            {
                throw new BusinessValidationException(validationErrors);
            }

            var cyberek = await _cyberekRepository.GetByIdAsync(cyberekId);
            if (cyberek == null)
            {
                throw new CyberekNotFoundException(cyberekId);
            }

            if (cyberek.GiftedCyberekId != 0)
                return new List<int> { cyberek.GiftedCyberekId };

            try
            {
                var allCyberki = await _cyberekRepository.GetAllAsync();
                return _giftingService.GetAvailableToBeGiftedCyberki(
                    allCyberki.ToList(),
                    cyberek.BannedCyberki);
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException("Failed to calculate available gift targets", ex);
            }
        }

        public async Task<bool> AssignGiftAsync(string userName, CyberekUpdateDTO updateDto)
        {
            var validationErrors = await _validationService.ValidateGiftAssignmentAsync(userName, updateDto);
            if (validationErrors.Any())
            {
                throw new BusinessValidationException(validationErrors);
            }

            var applicationUser = await _userRepository.GetByUsernameAsync(userName);
            if (applicationUser == null)
            {
                throw new UserNotFoundException(userName);
            }

            // Use database transaction for data consistency
            using var transaction = await _userRepository.BeginTransactionAsync();
            try
            {
                var allCyberki = await _cyberekRepository.GetAllAsync();
                var cyberkiList = allCyberki.ToList();

                if (applicationUser.CyberekId == 0)
                {
                    applicationUser.CyberekId = updateDto.CyberekId;
                    await _userRepository.UpdateAsync(applicationUser);
                    await _userRepository.SaveChangesAsync();
                    await transaction.CommitAsync();
                    return true;
                }

                var cyberek = cyberkiList.FirstOrDefault(c => c.Id == applicationUser.CyberekId);
                if (cyberek == null)
                {
                    throw new CyberekNotFoundException(applicationUser.CyberekId);
                }

                if (cyberek.GiftedCyberekId != 0)
                {
                    throw new InvalidGiftAssignmentException(
                        cyberek.Id, 
                        cyberek.GiftedCyberekId, 
                        CyberLosowanieConstants.GIFT_ALREADY_ASSIGNED);
                }

                cyberek.GiftedCyberekId = _giftingService.GetAvailableToBeGiftedCyberek(
                    cyberkiList, 
                    cyberek, 
                    updateDto.GiftedCyberekId);
                
                applicationUser.GiftedCyberekId = cyberek.GiftedCyberekId;

                await _cyberekRepository.UpdateAsync(cyberek);
                await _userRepository.UpdateAsync(applicationUser);
                
                // Save all changes in a single transaction
                await _cyberekRepository.SaveChangesAsync();
                await _userRepository.SaveChangesAsync();
                
                await transaction.CommitAsync();
                return true;
            }
            catch (Exception ex) when (!(ex is BusinessValidationException || ex is InvalidGiftAssignmentException))
            {
                await transaction.RollbackAsync();
                throw new InvalidOperationException("Failed to assign gift", ex);
            }
        }
    }
}